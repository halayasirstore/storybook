// ============================================================================
// LEVEL SERVICE - API calls and data management
// ============================================================================

import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:storio/features/stories/models/level_model.dart';
import 'package:storio/services/preferences_manager.dart';

class LevelService {
  // Change this URL to update the JSON data source
  static const String apiBaseUrl =
      'https://raw.githubusercontent.com/halayasirstore/storybook/refs/heads/main/halayasir.json';

  // Cache keys
  static const String _cacheKey = 'cached_levels_data';
  static const String _timestampKey = 'cached_levels_timestamp';
  // static const int _cacheExpirationMs = 300000; // 5 minutes for faster updates

  // ============================================================================
  // API DATA FETCHING
  // ============================================================================

  /// Fetch levels data from API with caching
  static Future<Map<String, dynamic>> fetchLevelsData() async {
    // Always fetch fresh data (no caching)
    debugPrint(
      'ğŸŒ Ø¬Ø§Ø±Ù Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø±Ù…Ø¬Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª: $apiBaseUrl',
    );

    try {
      debugPrint('ğŸŒ Ø¬Ø§Ø±Ù Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø±Ù…Ø¬Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª: $apiBaseUrl');

      final response = await http
          .get(
            Uri.parse(apiBaseUrl),
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
              'User-Agent': 'FlutterApp/1.0',
            },
          )
          .timeout(const Duration(seconds: 30));

      debugPrint(
        'ğŸ“¡ Ø­Ø§Ù„Ø© Ø§Ø³ØªØ¬Ø§Ø¨Ø© ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø±Ù…Ø¬Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª: ${response.statusCode}',
      );

      if (response.statusCode == 200) {
        debugPrint('âœ… ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø§Ø³ØªØ¬Ø§Ø¨Ø© ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø±Ù…Ø¬Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª Ø¨Ù†Ø¬Ø§Ø­');
        final data = jsonDecode(utf8.decode(response.bodyBytes));

        debugPrint('ğŸ“„ ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù…Ø¨Ø§Ø´Ø±Ø©');

        return data;
      } else {
        debugPrint('âŒ Ø®Ø·Ø£ ÙÙŠ ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø±Ù…Ø¬Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª: ${response.statusCode}');
        throw Exception(
          'ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø±Ù…Ø¬Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª: ${response.statusCode}',
        );
      }
    } on SocketException catch (e) {
      debugPrint('âŒ Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ø§Ù„Ù…Ù‚Ø¨Ø³: $e');
      throw Exception('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©: Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…');
    } on TimeoutException catch (e) {
      debugPrint('âŒ Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ù…Ù‡Ù„Ø©: $e');
      throw Exception('Ù…Ù‡Ù„Ø© Ø§Ù„Ø·Ù„Ø¨: Ø§Ø³ØªØºØ±Ù‚ Ø§Ù„Ø®Ø§Ø¯Ù… ÙˆÙ‚ØªÙ‹Ø§ Ø·ÙˆÙŠÙ„Ø§Ù‹ Ù„Ù„Ø±Ø¯');
    } on http.ClientException catch (e) {
      debugPrint('âŒ Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ø¹Ù…ÙŠÙ„ HTTP: $e');
      throw Exception('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©: ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªØµØ§Ù„Ùƒ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª');
    } catch (e) {
      debugPrint('âŒ Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹: $e');
      throw Exception('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©: $e');
    }
  }

  /// Fetch with retry mechanism
  static Future<Map<String, dynamic>> fetchWithRetry() async {
    const int maxRetries = 3;
    const Duration initialDelay = Duration(seconds: 2);

    for (int attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        debugPrint('ğŸ”„ Ù…Ø­Ø§ÙˆÙ„Ø© $attempt Ù…Ù† $maxRetries');
        return await fetchLevelsData();
      } catch (e) {
        debugPrint('âŒ ÙØ´Ù„Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© $attempt: $e');

        if (attempt == maxRetries) {
          rethrow;
        }

        final delay = initialDelay * (attempt * attempt);
        debugPrint('â³ Ø§Ù†ØªØ¸Ø§Ø± ${delay.inSeconds} Ø«Ø§Ù†ÙŠØ© Ù‚Ø¨Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©...');
        await Future.delayed(delay);
      }
    }

    throw Exception('ÙØ´Ù„Øª Ø¬Ù…ÙŠØ¹ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©');
  }

  /// Clear cached data (useful for manual refresh)
  static Future<void> clearCache() async {
    await PreferencesManager.remove(_cacheKey);
    await PreferencesManager.remove(_timestampKey);
    debugPrint('ğŸ—‘ï¸ ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©');
  }

  /// Force refresh data (bypasses cache)
  static Future<Map<String, dynamic>> forceRefresh() async {
    await clearCache();
    return await fetchLevelsData();
  }

  // ============================================================================
  // LEVEL BUILDING
  // ============================================================================

  /// Build level progress objects from API data
  static Future<List<LevelProgress>> buildLevelsFromApiData(
    Map<String, dynamic> apiData,
  ) async {
    final List<dynamic> levelsData = apiData['levels'] ?? [];

    if (levelsData.isEmpty) {
      debugPrint('âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø³ØªÙˆÙŠØ§Øª ÙÙŠ Ø§Ø³ØªØ¬Ø§Ø¨Ø© ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø±Ù…Ø¬Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª');
      return [];
    }

    debugPrint('âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${levelsData.length} Ù…Ø³ØªÙˆÙŠØ§Øª');

    List<LevelProgress> loadedLevels = [];

    for (int i = 0; i < levelsData.length; i++) {
      final levelData = levelsData[i];
      final stories = levelData['stories'] as List? ?? [];

      // Check level accessibility
      bool isLevelAccessible = await isLevelUnlocked(
        i,
        await PreferencesManager.getInstance(),
      );

      // Calculate scores and progress
      int levelQuizScore = await calculateLevelQuizScore(
        levelData,
        await PreferencesManager.getInstance(),
      );
      int maxPossibleScore = calculateMaxPossibleQuizScore(levelData);
      bool isCompleted = levelQuizScore >= (maxPossibleScore * 0.7);

      // Calculate words data
      int wordsLearned = await calculateWordsLearnedInLevel(
        levelData,
        await PreferencesManager.getInstance(),
      );
      int totalWords = calculateTotalWordsInLevel(levelData);

      loadedLevels.add(
        LevelProgress(
          level: levelData['name'] ?? 'Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${i + 1}',
          progress: 0,
          total: stories.length,
          completed: isCompleted,
          color: parseColor(levelData['color']),
          gradient: LinearGradient(
            colors: parseGradientColors(levelData['gradient']),
          ),
          routeName: '/level${i + 1}',
          levelData: levelData,
          isLocked: !isLevelAccessible,
          lockMessage: i == 0 ? '' : 'Ø£ÙƒÙ…Ù„ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ $i Ù„ÙØªØ­Ù‡',
          levelIndex: i + 1,
          wordsLearned: wordsLearned,
          totalWords: totalWords,
          quizScore: levelQuizScore,
          maxQuizScore: maxPossibleScore,
        ),
      );

      debugPrint('   âœ… ØªÙ… Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${i + 1}: ${levelData['name']}');
    }

    return loadedLevels;
  }

  // ============================================================================
  // PROGRESS CALCULATIONS
  // ============================================================================

  /// Check if a level is unlocked
  static Future<bool> isLevelUnlocked(int levelIndex, dynamic prefs) async {
    // First level is always unlocked
    if (levelIndex == 0) return true;

    // Check if previous level is completed
    final previousLevelKey = 'level_$levelIndex';
    final previousLevelCompleted =
        await PreferencesManager.getBool('${previousLevelKey}_completed') ??
        false;

    // Check if level was manually unlocked
    final levelAccessible =
        await PreferencesManager.getBool(
          'level_${levelIndex + 1}_accessible',
        ) ??
        false;

    return previousLevelCompleted || levelAccessible;
  }

  /// Calculate total quiz score for a level
  static Future<int> calculateLevelQuizScore(
    Map<String, dynamic> levelData,
    dynamic prefs,
  ) async {
    final stories = levelData['stories'] as List? ?? [];
    int totalQuizScore = 0;

    for (final story in stories) {
      final storyName = story['name'];
      final quizScore = await PreferencesManager.getQuizScore(storyName);
      totalQuizScore += quizScore;
    }

    return totalQuizScore;
  }

  /// Calculate maximum possible quiz score
  static int calculateMaxPossibleQuizScore(Map<String, dynamic> levelData) {
    final stories = levelData['stories'] as List? ?? [];
    return stories.length * 10; // 10 questions per story
  }

  /// Calculate total unique words in level
  static int calculateTotalWordsInLevel(Map<String, dynamic> levelData) {
    final Set<String> uniqueWords = {};
    final stories = levelData['stories'] as List? ?? [];

    for (final story in stories) {
      final segments = story['story']['segmentsList'] as List? ?? [];
      for (final segment in segments) {
        final content = segment['content'] as String? ?? '';
        final words = content
            .split(' ')
            .map(
              (word) =>
                  word.replaceAll(RegExp(r'[.,!?;:]'), '').toLowerCase().trim(),
            )
            .where((word) => word.isNotEmpty);

        uniqueWords.addAll(words);
      }
    }

    return uniqueWords.length;
  }

  /// Calculate words learned in level
  static Future<int> calculateWordsLearnedInLevel(
    Map<String, dynamic> levelData,
    dynamic prefs,
  ) async {
    final Set<String> learnedWords = {};
    final stories = levelData['stories'] as List? ?? [];

    for (final story in stories) {
      final storyName = story['name'];
      final storyLearnedWords = await PreferencesManager.getLearnedWords(
        storyName,
      );
      learnedWords.addAll(storyLearnedWords);
    }

    return learnedWords.length;
  }

  /// Update level with calculated progress
  static Future<void> saveLevelProgress(
    int levelIndex,
    LevelProgress level,
    dynamic prefs,
  ) async {
    final levelKey = 'level_${levelIndex + 1}';
    final totalWords = level.totalWords;
    final wordsLearned = level.wordsLearned;
    final progress = totalWords > 0 ? wordsLearned / totalWords : 0.0;

    await PreferencesManager.setDouble('${levelKey}_progress', progress);
    await PreferencesManager.setBool('${levelKey}_completed', level.completed);
    await PreferencesManager.setInt('${levelKey}_words_learned', wordsLearned);
    await PreferencesManager.setInt('${levelKey}_total_words', totalWords);
    await PreferencesManager.setInt('${levelKey}_quiz_score', level.quizScore);

    // Auto unlock next level if current is completed
    if (level.completed) {
      final nextLevelKey = 'level_${levelIndex + 2}';
      await PreferencesManager.setBool('${nextLevelKey}_accessible', true);
      debugPrint('   ğŸ”“ ØªÙ… ÙØªØ­ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${levelIndex + 2} ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§');
    }
  }

  // ============================================================================
  // COLOR PARSING
  // ============================================================================

  /// Parse color from dynamic value
  static Color parseColor(dynamic colorValue) {
    try {
      if (colorValue is int) return Color(colorValue);
      if (colorValue is String) return Color(int.parse(colorValue));
      return Colors.grey;
    } catch (e) {
      return Colors.grey;
    }
  }

  /// Parse gradient colors
  static List<Color> parseGradientColors(dynamic gradientData) {
    try {
      if (gradientData is! Map) return [Colors.grey, Colors.grey];
      final colorsData = gradientData['colors'] as List? ?? [];
      return colorsData.map((colorValue) => parseColor(colorValue)).toList();
    } catch (e) {
      return [Colors.grey, Colors.grey];
    }
  }

  // ============================================================================
  // IMAGE HELPERS
  // ============================================================================

  /// Get a random story image from level
  static String getRandomStoryImageFromLevel(Map<String, dynamic> levelData) {
    final stories = levelData['stories'] as List? ?? [];
    if (stories.isEmpty) return '';

    final randomIndex = DateTime.now().millisecondsSinceEpoch % stories.length;
    final randomStory = stories[randomIndex];

    final storyImage = randomStory['image'] ?? '';
    final coverImage = randomStory['story']?['coverImage'] ?? '';

    return storyImage.isNotEmpty ? storyImage : coverImage;
  }
}
