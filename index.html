// ============================================================================
// LEVEL SERVICE - API calls and data management
// ============================================================================

import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:storio/features/stories/models/level_model.dart';
import 'package:storio/services/preferences_manager.dart';

class LevelService {
  // Change this URL to update the JSON data source
  static const String apiBaseUrl =
      'https://raw.githubusercontent.com/halayasirstore/storybook/refs/heads/main/halayasir.json';

  // Cache keys
  static const String _cacheKey = 'cached_levels_data';
  static const String _timestampKey = 'cached_levels_timestamp';
  // static const int _cacheExpirationMs = 300000; // 5 minutes for faster updates

  // ============================================================================
  // API DATA FETCHING
  // ============================================================================

  /// Fetch levels data from API with caching
  static Future<Map<String, dynamic>> fetchLevelsData() async {
    // Always fetch fresh data (no caching)
    debugPrint(
      '🌐 جارٍ جلب البيانات الجديدة من واجهة برمجة التطبيقات: $apiBaseUrl',
    );

    try {
      debugPrint('🌐 جارٍ جلب البيانات من واجهة برمجة التطبيقات: $apiBaseUrl');

      final response = await http
          .get(
            Uri.parse(apiBaseUrl),
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
              'User-Agent': 'FlutterApp/1.0',
            },
          )
          .timeout(const Duration(seconds: 30));

      debugPrint(
        '📡 حالة استجابة واجهة برمجة التطبيقات: ${response.statusCode}',
      );

      if (response.statusCode == 200) {
        debugPrint('✅ تم استلام استجابة واجهة برمجة التطبيقات بنجاح');
        final data = jsonDecode(utf8.decode(response.bodyBytes));

        debugPrint('📄 تم تحميل البيانات الجديدة مباشرة');

        return data;
      } else {
        debugPrint('❌ خطأ في واجهة برمجة التطبيقات: ${response.statusCode}');
        throw Exception(
          'فشل تحميل البيانات من واجهة برمجة التطبيقات: ${response.statusCode}',
        );
      }
    } on SocketException catch (e) {
      debugPrint('❌ استثناء المقبس: $e');
      throw Exception('خطأ في الشبكة: لا يمكن الاتصال بالخادم');
    } on TimeoutException catch (e) {
      debugPrint('❌ استثناء انتهاء المهلة: $e');
      throw Exception('مهلة الطلب: استغرق الخادم وقتًا طويلاً للرد');
    } on http.ClientException catch (e) {
      debugPrint('❌ استثناء عميل HTTP: $e');
      throw Exception('خطأ في الشبكة: يرجى التحقق من اتصالك بالإنترنت');
    } catch (e) {
      debugPrint('❌ خطأ غير متوقع: $e');
      throw Exception('خطأ في الشبكة: $e');
    }
  }

  /// Fetch with retry mechanism
  static Future<Map<String, dynamic>> fetchWithRetry() async {
    const int maxRetries = 3;
    const Duration initialDelay = Duration(seconds: 2);

    for (int attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        debugPrint('🔄 محاولة $attempt من $maxRetries');
        return await fetchLevelsData();
      } catch (e) {
        debugPrint('❌ فشلت المحاولة $attempt: $e');

        if (attempt == maxRetries) {
          rethrow;
        }

        final delay = initialDelay * (attempt * attempt);
        debugPrint('⏳ انتظار ${delay.inSeconds} ثانية قبل إعادة المحاولة...');
        await Future.delayed(delay);
      }
    }

    throw Exception('فشلت جميع محاولات إعادة المحاولة');
  }

  /// Clear cached data (useful for manual refresh)
  static Future<void> clearCache() async {
    await PreferencesManager.remove(_cacheKey);
    await PreferencesManager.remove(_timestampKey);
    debugPrint('🗑️ تم مسح الذاكرة المؤقتة');
  }

  /// Force refresh data (bypasses cache)
  static Future<Map<String, dynamic>> forceRefresh() async {
    await clearCache();
    return await fetchLevelsData();
  }

  // ============================================================================
  // LEVEL BUILDING
  // ============================================================================

  /// Build level progress objects from API data
  static Future<List<LevelProgress>> buildLevelsFromApiData(
    Map<String, dynamic> apiData,
  ) async {
    final List<dynamic> levelsData = apiData['levels'] ?? [];

    if (levelsData.isEmpty) {
      debugPrint('⚠️ لا توجد بيانات مستويات في استجابة واجهة برمجة التطبيقات');
      return [];
    }

    debugPrint('✅ تم العثور على ${levelsData.length} مستويات');

    List<LevelProgress> loadedLevels = [];

    for (int i = 0; i < levelsData.length; i++) {
      final levelData = levelsData[i];
      final stories = levelData['stories'] as List? ?? [];

      // Check level accessibility
      bool isLevelAccessible = await isLevelUnlocked(
        i,
        await PreferencesManager.getInstance(),
      );

      // Calculate scores and progress
      int levelQuizScore = await calculateLevelQuizScore(
        levelData,
        await PreferencesManager.getInstance(),
      );
      int maxPossibleScore = calculateMaxPossibleQuizScore(levelData);
      bool isCompleted = levelQuizScore >= (maxPossibleScore * 0.7);

      // Calculate words data
      int wordsLearned = await calculateWordsLearnedInLevel(
        levelData,
        await PreferencesManager.getInstance(),
      );
      int totalWords = calculateTotalWordsInLevel(levelData);

      loadedLevels.add(
        LevelProgress(
          level: levelData['name'] ?? 'المستوى ${i + 1}',
          progress: 0,
          total: stories.length,
          completed: isCompleted,
          color: parseColor(levelData['color']),
          gradient: LinearGradient(
            colors: parseGradientColors(levelData['gradient']),
          ),
          routeName: '/level${i + 1}',
          levelData: levelData,
          isLocked: !isLevelAccessible,
          lockMessage: i == 0 ? '' : 'أكمل المستوى $i لفتحه',
          levelIndex: i + 1,
          wordsLearned: wordsLearned,
          totalWords: totalWords,
          quizScore: levelQuizScore,
          maxQuizScore: maxPossibleScore,
        ),
      );

      debugPrint('   ✅ تم بناء المستوى ${i + 1}: ${levelData['name']}');
    }

    return loadedLevels;
  }

  // ============================================================================
  // PROGRESS CALCULATIONS
  // ============================================================================

  /// Check if a level is unlocked
  static Future<bool> isLevelUnlocked(int levelIndex, dynamic prefs) async {
    // First level is always unlocked
    if (levelIndex == 0) return true;

    // Check if previous level is completed
    final previousLevelKey = 'level_$levelIndex';
    final previousLevelCompleted =
        await PreferencesManager.getBool('${previousLevelKey}_completed') ??
        false;

    // Check if level was manually unlocked
    final levelAccessible =
        await PreferencesManager.getBool(
          'level_${levelIndex + 1}_accessible',
        ) ??
        false;

    return previousLevelCompleted || levelAccessible;
  }

  /// Calculate total quiz score for a level
  static Future<int> calculateLevelQuizScore(
    Map<String, dynamic> levelData,
    dynamic prefs,
  ) async {
    final stories = levelData['stories'] as List? ?? [];
    int totalQuizScore = 0;

    for (final story in stories) {
      final storyName = story['name'];
      final quizScore = await PreferencesManager.getQuizScore(storyName);
      totalQuizScore += quizScore;
    }

    return totalQuizScore;
  }

  /// Calculate maximum possible quiz score
  static int calculateMaxPossibleQuizScore(Map<String, dynamic> levelData) {
    final stories = levelData['stories'] as List? ?? [];
    return stories.length * 10; // 10 questions per story
  }

  /// Calculate total unique words in level
  static int calculateTotalWordsInLevel(Map<String, dynamic> levelData) {
    final Set<String> uniqueWords = {};
    final stories = levelData['stories'] as List? ?? [];

    for (final story in stories) {
      final segments = story['story']['segmentsList'] as List? ?? [];
      for (final segment in segments) {
        final content = segment['content'] as String? ?? '';
        final words = content
            .split(' ')
            .map(
              (word) =>
                  word.replaceAll(RegExp(r'[.,!?;:]'), '').toLowerCase().trim(),
            )
            .where((word) => word.isNotEmpty);

        uniqueWords.addAll(words);
      }
    }

    return uniqueWords.length;
  }

  /// Calculate words learned in level
  static Future<int> calculateWordsLearnedInLevel(
    Map<String, dynamic> levelData,
    dynamic prefs,
  ) async {
    final Set<String> learnedWords = {};
    final stories = levelData['stories'] as List? ?? [];

    for (final story in stories) {
      final storyName = story['name'];
      final storyLearnedWords = await PreferencesManager.getLearnedWords(
        storyName,
      );
      learnedWords.addAll(storyLearnedWords);
    }

    return learnedWords.length;
  }

  /// Update level with calculated progress
  static Future<void> saveLevelProgress(
    int levelIndex,
    LevelProgress level,
    dynamic prefs,
  ) async {
    final levelKey = 'level_${levelIndex + 1}';
    final totalWords = level.totalWords;
    final wordsLearned = level.wordsLearned;
    final progress = totalWords > 0 ? wordsLearned / totalWords : 0.0;

    await PreferencesManager.setDouble('${levelKey}_progress', progress);
    await PreferencesManager.setBool('${levelKey}_completed', level.completed);
    await PreferencesManager.setInt('${levelKey}_words_learned', wordsLearned);
    await PreferencesManager.setInt('${levelKey}_total_words', totalWords);
    await PreferencesManager.setInt('${levelKey}_quiz_score', level.quizScore);

    // Auto unlock next level if current is completed
    if (level.completed) {
      final nextLevelKey = 'level_${levelIndex + 2}';
      await PreferencesManager.setBool('${nextLevelKey}_accessible', true);
      debugPrint('   🔓 تم فتح المستوى ${levelIndex + 2} تلقائيًا');
    }
  }

  // ============================================================================
  // COLOR PARSING
  // ============================================================================

  /// Parse color from dynamic value
  static Color parseColor(dynamic colorValue) {
    try {
      if (colorValue is int) return Color(colorValue);
      if (colorValue is String) return Color(int.parse(colorValue));
      return Colors.grey;
    } catch (e) {
      return Colors.grey;
    }
  }

  /// Parse gradient colors
  static List<Color> parseGradientColors(dynamic gradientData) {
    try {
      if (gradientData is! Map) return [Colors.grey, Colors.grey];
      final colorsData = gradientData['colors'] as List? ?? [];
      return colorsData.map((colorValue) => parseColor(colorValue)).toList();
    } catch (e) {
      return [Colors.grey, Colors.grey];
    }
  }

  // ============================================================================
  // IMAGE HELPERS
  // ============================================================================

  /// Get a random story image from level
  static String getRandomStoryImageFromLevel(Map<String, dynamic> levelData) {
    final stories = levelData['stories'] as List? ?? [];
    if (stories.isEmpty) return '';

    final randomIndex = DateTime.now().millisecondsSinceEpoch % stories.length;
    final randomStory = stories[randomIndex];

    final storyImage = randomStory['image'] ?? '';
    final coverImage = randomStory['story']?['coverImage'] ?? '';

    return storyImage.isNotEmpty ? storyImage : coverImage;
  }
}
